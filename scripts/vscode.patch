diff --git a/src/vs/code/electron-browser/sharedProcess/sharedProcessMain.ts b/src/vs/code/electron-browser/sharedProcess/sharedProcessMain.ts
index 457818a975..ad45ffe58a 100644
--- a/src/vs/code/electron-browser/sharedProcess/sharedProcessMain.ts
+++ b/src/vs/code/electron-browser/sharedProcess/sharedProcessMain.ts
@@ -194,3 +194,5 @@ async function handshake(configuration: ISharedProcessConfiguration): Promise<vo
 	main(server, data, configuration);
 	ipcRenderer.send('handshake:im ready');
 }
+
+startup({ machineId: "1" });
diff --git a/src/vs/loader.js b/src/vs/loader.js
index 2bf7fe37d7..81cc668f12 100644
--- a/src/vs/loader.js
+++ b/src/vs/loader.js
@@ -667,10 +667,10 @@ var AMDLoader;
             }
             this._didInitialize = true;
             // capture node modules
-            this._fs = nodeRequire('fs');
-            this._vm = nodeRequire('vm');
-            this._path = nodeRequire('path');
-            this._crypto = nodeRequire('crypto');
+            this._fs = require('fs');
+            this._vm = require('vm');
+            this._path = require('path');
+            this._crypto = require('crypto');
         };
         // patch require-function of nodejs such that we can manually create a script
         // from cached data. this is done by overriding the `Module._compile` function
@@ -731,11 +731,18 @@ var AMDLoader;
             this._init(nodeRequire);
             this._initNodeRequire(nodeRequire, moduleManager);
             var recorder = moduleManager.getRecorder();
+            const context = require.context("../", true, /.*/);
+            if (scriptSrc.indexOf("file:///") !== -1) {
+                const vsSrc = scriptSrc.split("file:///")[1].split(".js")[0];
+                if (vsSrc && vsSrc.startsWith("vs/")) {
+                  scriptSrc = `node|./${vsSrc}`;
+                }
+            }
             if (/^node\|/.test(scriptSrc)) {
                 var pieces = scriptSrc.split('|');
                 var moduleExports_1 = null;
                 try {
-                    moduleExports_1 = nodeRequire(pieces[1]);
+                    moduleExports_1 = context(pieces[1]);
                 }
                 catch (err) {
                     errorback(err);
diff --git a/src/vs/workbench/electron-browser/main.ts b/src/vs/workbench/electron-browser/main.ts
index a43d63aa51..4c6df2fcd9 100644
--- a/src/vs/workbench/electron-browser/main.ts
+++ b/src/vs/workbench/electron-browser/main.ts
@@ -147,13 +147,14 @@ function openWorkbench(configuration: IWindowConfiguration): Promise<void> {
 				shell.open();
 
 				// Inform user about loading issues from the loader
-				(<any>self).require.config({
-					onError: err => {
-						if (err.errorCode === 'load') {
-							shell.onUnexpectedError(new Error(nls.localize('loaderErrorNative', "Failed to load a required file. Please restart the application to try again. Details: {0}", JSON.stringify(err))));
-						}
-					}
-				});
+				// TODO: how to make this work
+				// (<any>self).require.config({
+				// 	onError: err => {
+				// 		if (err.errorCode === 'load') {
+				// 			shell.onUnexpectedError(new Error(nls.localize('loaderErrorNative', "Failed to load a required file. Please restart the application to try again. Details: {0}", JSON.stringify(err))));
+				// 		}
+				// 	}
+				// });
 			});
 		});
 	});
diff --git a/src/vs/workbench/node/extensionHostProcess.ts b/src/vs/workbench/node/extensionHostProcess.ts
index 8d182d18d9..69d51e1aea 100644
--- a/src/vs/workbench/node/extensionHostProcess.ts
+++ b/src/vs/workbench/node/extensionHostProcess.ts
@@ -129,7 +129,7 @@ function connectToRenderer(protocol: IMessagePassingProtocol): Promise<IRenderer
 			// Kill oneself if one's parent dies. Much drama.
 			setInterval(function () {
 				try {
-					process.kill(initData.parentPid, 0); // throws an exception if the main process doesn't exist anymore.
+					// process.kill(initData.parentPid, 0); // throws an exception if the main process doesn't exist anymore.
 				} catch (e) {
 					onTerminate();
 				}
diff --git a/src/vs/workbench/parts/welcome/walkThrough/node/walkThroughContentProvider.ts b/src/vs/workbench/parts/welcome/walkThrough/node/walkThroughContentProvider.ts
index 7b4e8721ac..8f26dc2f28 100644
--- a/src/vs/workbench/parts/welcome/walkThrough/node/walkThroughContentProvider.ts
+++ b/src/vs/workbench/parts/welcome/walkThrough/node/walkThroughContentProvider.ts
@@ -28,7 +28,9 @@ export class WalkThroughContentProvider implements ITextModelContentProvider, IW
 	public provideTextContent(resource: URI): Thenable<ITextModel> {
 		const query = resource.query ? JSON.parse(resource.query) : {};
 		const content: Thenable<string | ITextBufferFactory> = (query.moduleId ? new Promise<string>((resolve, reject) => {
-			require([query.moduleId], content => {
+			// Webpack needs this to be static or it can't include it.
+			import("vs/workbench/parts/welcome/page/electron-browser/vs_code_welcome_page").then((content) => {
+			// require([query.moduleId], content => {
 				try {
 					resolve(content.default());
 				} catch (err) {
